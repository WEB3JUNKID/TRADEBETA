<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>TradeBeta</title>
<style>
  :root{
    --bg:#07121a; --muted:#9fb2c8; --accent:#59c6ff; --good:#86efac; --bad:#ff7b7b;
    --card-bg: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
  }
  html,body{margin:0;padding:0;height:100%;}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg),#031219);color:#e6f3fb;padding:18px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:20px;color:var(--accent)}
  .sub{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  button,select{background:#0b1520;border:1px solid rgba(255,255,255,0.03);color:#cfe8ff;padding:8px;border-radius:8px}
  #grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(360px,1fr));gap:12px;margin-top:12px}
  .card{background:var(--card-bg);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .h{display:flex;justify-content:space-between;align-items:center}
  .mono{font-family:ui-monospace,Menlo,Monaco,"Roboto Mono",monospace}
  .small{font-size:12px;color:var(--muted)}
  .long{color:var(--good);font-weight:700}
  .short{color:var(--bad);font-weight:700}
  .neutral{color:var(--muted);font-weight:700}
  .sig{margin-top:8px}
  .muted{color:var(--muted)}
  .spinner{width:14px;height:14px;border:2px solid rgba(255,255,255,0.06);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;display:inline-block;margin-left:8px}
  @keyframes spin{to{transform:rotate(360deg)}}
  footer{margin-top:14px;color:var(--muted);font-size:13px}
  @media (max-width:760px){#grid{grid-template-columns:1fr}}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:12px}
  details summary{cursor:pointer}
  .muted-block{margin-top:8px;color:var(--muted);font-size:12px}

  /* small action styling */
  .track-btn {
    padding:8px 12px;border:none;border-radius:8px;background:linear-gradient(45deg,#3b82f6,#1e40af);color:#fff;font-size:14px;cursor:pointer;
  }
</style>
</head>
<body>
<header style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px;padding-bottom:12px;border-bottom:1px solid rgba(255,255,255,0.08);">
  <!-- Left: Logo + Name -->
  <div style="display:flex;align-items:center;gap:10px">
    <div style="width:40px;height:40px;background:linear-gradient(135deg,#00d4ff,#59c6ff);border-radius:50%;display:flex;justify-content:center;align-items:center;font-weight:bold;font-size:20px;color:#07121a;">TÎ²</div>
    <div>
      <h1 style="margin:0;font-size:20px;color:#00d4ff;">TradeBeta</h1>
      <div class="sub" style="font-size:13px;color:#9fb2c8;">Your go-to Market analyst</div>
    </div>
  </div>

<!-- Right: Controls (mobile-friendly) -->
<div class="controls" style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
  <button id="refreshBtn" style="flex:1;min-width:80px;">Refresh</button>
  <button onclick="window.open('history.html','_blank')" style="flex:1;min-width:80px;">History</button>
  <button onclick="window.open('watchlist.html','_blank')" style="flex:1;min-width:80px;">WatchList</button>

  <label class="small" style="flex:1;min-width:120px;"> TradeBeta<selec id="interval" style="width:100%;">
      
      
<div class="small" style="flex:1;min-width:120px;">
  Scan interval: <strong>5m</strong>
</div>
  </label>

  <label class="small" style="flex:1;min-width:120px;">Display top:
    <select id="displayCount" style="width:100%;">
      <option value="10">10</option>
      <option value="20" selected>20</option>
      <option value="50">50</option>
      <option value="100">100</option>
    </select>
  </label>

  <div id="status" class="small" style="margin-left:10px;flex-basis:100%;">Idle</div>
</div>

  <div id="grid"></div>

  <footer class="small muted">
Trading financial markets involves substantial risk. Prices can move rapidly, and you may lose part or all of your invested capital. Past performance is not indicative of future results. Only trade with money you can afford to lose, use proper risk management, and avoid making decisions based solely on tips or automated signals. Leverage can magnify both gains and losses.
  </footer>

<script type="module">
  // === Firebase Auth + Firestore ===
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
  import { getFirestore, collection, addDoc } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyA1vuT6ymi7vCcn7SPE7gZKN1MyD0zBuGc",
    authDomain: "tradebeta-18ffc.firebaseapp.com",
    projectId: "tradebeta-18ffc",
    storageBucket: "tradebeta-18ffc.firebasestorage.app",
    messagingSenderId: "786972465731",
    appId: "1:786972465731:web:7e2a6e49a36fb238e212f6",
    measurementId: "G-DLFY9P02CG"
  };
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ensure only logged in users can access dashboard (redirect to login)
  onAuthStateChanged(auth, (user) => {
    if (!user) window.location.href = "login.html";
  });

  /* ========== CONFIG ========== */
  const COINGECKO = "https://api.coingecko.com/api/v3";
  const TOP_SCAN = 100;
  const RR = 3;
  const EXCLUDE_STABLES = ["tether","usd-coin","dai","binance-usd","true-usd","frax","usdd","first-digital-usd"];
  const ATR_PERIOD = 14;
  const OVEREXT_PCT = 10;
  let intervalMs = 300000; // Default to 5 minutes
  let displayCount = Number(document.getElementById('displayCount').value);
  let loopHandle = null;

  /* persistent state */
  if(!window.signals) window.signals = {}; // keyed by coin.id
  if(!window.cardMap) window.cardMap = new Map();
  if(!window.cardData) window.cardData = {}; // store snapshot per coin for track

  /* ========== UTIL ========== */
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function fmtUSD(x){ if(x==null || isNaN(x)) return "N/A"; if(Math.abs(x)>=1000) return "$"+Number(x).toLocaleString(undefined,{maximumFractionDigits:2}); return "$"+Number(x).toFixed(2); }
  function roundN(x,n=2){ return Number(Number(x).toFixed(n)); }

  /* EMA, ATR, PA, OB, pivots, etc. (unchanged) */
  function emaSeriesFromCloses(closes, period){
    const out = new Array(closes.length).fill(null);
    if(closes.length < period) return out;
    let sum=0;
    for(let i=0;i<period;i++) sum += closes[i];
    let prev = sum/period;
    out[period-1] = prev;
    const k = 2/(period+1);
    for(let i=period;i<closes.length;i++){
      prev = closes[i]*k + prev*(1-k);
      out[i] = prev;
    }
    return out;
  }
  function ATR(highs,lows,closes,period=14){
    if(!highs || highs.length < period+1) return null;
    const TR = [];
    for(let i=1;i<highs.length;i++){
      const tr = Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1]));
      TR.push(tr);
    }
    if(TR.length < period) return null;
    let atr = TR.slice(0,period).reduce((s,v)=>s+v,0)/period;
    for(let i=period;i<TR.length;i++){
      atr = ((atr*(period-1)) + TR[i]) / period;
    }
    return atr;
  }
  function detectPA(candles){
    if(!candles || candles.length < 2) return {engulf:null, wick:null};
    const last = candles[candles.length-1];
    const prev = candles[candles.length-2];
    const prevBody = Math.abs(prev.c - prev.o);
    const lastBody = Math.abs(last.c - last.o);
    let engulf = null;
    if(prev.c < prev.o && last.c > last.o && lastBody > prevBody && last.c > prev.o && last.o < prev.c) engulf = "bull";
    else if(prev.c > prev.o && last.c < last.o && lastBody > prevBody && last.o > prev.c && last.c < prev.o) engulf = "bear";
    const body = lastBody;
    const upperWick = last.h - Math.max(last.c,last.o);
    const lowerWick = Math.min(last.c,last.o) - last.l;
    let wick = null;
    if(lowerWick > body*2.5 && body < (last.h-last.l)*0.35) wick = "lower-rej";
    else if(upperWick > body*2.5 && body < (last.h-last.l)*0.35) wick = "upper-rej";
    return {engulf, wick};
  }
  function findOrderBlocks(candles, lookback=60){
    const n = candles.length;
    const start = Math.max(2, n - lookback);
    let bullOB = null, bearOB = null;
    for(let i=n-3;i>=start;i--){
      const c = candles[i];
      if(!bullOB && c.c < c.o){
        for(let j=i+1;j<=Math.min(i+3,n-1);j++){
          if(candles[j].c > c.o * 1.01){
            bullOB = {index:i, low:c.l, high:c.h};
            break;
          }
        }
      }
      if(!bearOB && c.c > c.o){
        for(let j=i+1;j<=Math.min(i+3,n-1);j++){
          if(candles[j].c < c.o * 0.99){
            bearOB = {index:i, low:c.l, high:c.h};
            break;
          }
        }
      }
      if(bullOB && bearOB) break;
    }
    return {bullOB, bearOB};
  }
  function pivots_from_prev(prevHigh, prevLow, prevClose){
    const P = (prevHigh + prevLow + prevClose)/3;
    return { P, R1:(2*P)-prevLow, S1:(2*P)-prevHigh };
  }
  function zoneOverlapRatio(z1, z2){
    if(!z1 || !z2) return 0;
    const low = Math.max(z1.low, z2.low);
    const high = Math.min(z1.high, z2.high);
    if(high <= low) return 0;
    const inter = high - low;
    const union = Math.max(z1.high, z2.high) - Math.min(z1.low, z2.low);
    return inter/union;
  }
  function buildOHLCFromDailyCloses(prices){
    if(!prices || prices.length < 2) return null;
    const out = [];
    for(let i=1;i<prices.length;i++){
      const open = prices[i-1][1];
      const close = prices[i][1];
      const high = Math.max(open, close);
      const low = Math.min(open, close);
      out.push({t: prices[i][0], o: open, h: high, l: low, c: close});
    }
    return out;
  }

  /* ================== FETCH HELPERS (OHLC robust) ================== */
  async function fetchTopCoins(n=TOP_SCAN){
    try {
      const url = `${COINGECKO}/coins/markets?vs_currency=usd&order=volume_desc&per_page=${n}&page=1&sparkline=false`;
      const r = await fetch(url);
      if(!r.ok) throw new Error("markets fetch failed");
      const list = await r.json();
      return list.filter(c=>{
        const id=(c.id||"").toLowerCase();
        if(EXCLUDE_STABLES.some(x=> id.includes(x))) return false;
        if(id.includes("usd")) return false;
        return true;
      });
    } catch(e){
      console.error("fetchTopCoins", e);
      return [];
    }
  }

  async function fetchDailyOHLC(coinId){
    const tryDays = [30,14,7,2];
    for(const d of tryDays){
      try {
        const url = `${COINGECKO}/coins/${encodeURIComponent(coinId)}/ohlc?vs_currency=usd&days=${d}`;
        const r = await fetch(url);
        if(r.ok){
          const j = await r.json();
          if(Array.isArray(j) && j.length >= 2){
            const candles = j.map(item => ({t: item[0], o: item[1], h: item[2], l: item[3], c: item[4]}));
            return candles;
          }
        }
      } catch(e){}
      await sleep(120);
    }

    for(const d of tryDays){
      try {
        const url = `${COINGECKO}/coins/${encodeURIComponent(coinId)}/market_chart?vs_currency=usd&days=${d}&interval=daily`;
        const r = await fetch(url);
        if(!r.ok) continue;
        const j = await r.json();
        if(j && Array.isArray(j.prices) && j.prices.length >= 2){
          const synthesized = buildOHLCFromDailyCloses(j.prices);
          if(synthesized && synthesized.length >= 2) return synthesized;
        }
      } catch(e){}
      await sleep(120);
    }
    return null;
  }

  async function fetchCurrentPrice(coinId){
    try {
      const url = `${COINGECKO}/simple/price?ids=${encodeURIComponent(coinId)}&vs_currencies=usd`;
      const r = await fetch(url);
      if(!r.ok) return null;
      const j = await r.json();
      if(j && j[coinId] && j[coinId].usd) return j[coinId].usd;
      return null;
    } catch(e){ return null; }
  }

  /* ================== SIGNAL GENERATION (daily OHLC) ================== */
  function generateDailySignal(prev, last, piv, ob){
    const open = prev.o, close = last.c;
    const range = Math.abs(close - open);
    if(range === 0) return null;
    let type = (close > open) ? "LONG" : "SHORT";
    let sl = null, tp = null;
    if(type === "LONG"){ sl = close - range; tp = close + range * RR; }
    else { sl = close + range; tp = close - range * RR; }
    const reasons = [];
    if(piv){
      if(type === "LONG" && piv.S1 && Math.abs(close - piv.S1)/piv.S1 < 0.01) reasons.push("Pivot S1");
      if(type === "SHORT" && piv.R1 && Math.abs(close - piv.R1)/piv.R1 < 0.01) reasons.push("Pivot R1");
    }
    if(ob){
      if(type==="LONG" && ob.bullOB) reasons.push("Bull OB");
      if(type==="SHORT" && ob.bearOB) reasons.push("Bear OB");
    }
    return {
      date: new Date(prev.t).toLocaleDateString(),
      price: roundN(close,2),
      type,
      stopLoss: roundN(sl,2),
      takeProfit: roundN(tp,2),
      status: "OPEN",
      reason: reasons.length ? reasons.join(" â¢ ") : "Candle"
    };
  }

  function scoreConfidence({emaAlign, paConfirm, obMatch, pivotMatch, notOverext}){
    let s=0; if(emaAlign) s+=35; if(paConfirm) s+=25; if(obMatch) s+=20; if(pivotMatch) s+=10; if(notOverext) s+=10;
    return Math.min(100, s);
  }

  function archiveTrade(coinId, sig){
    let history = JSON.parse(localStorage.getItem("historyTrades") || "[]");
    history.push({ coinId, ...sig, archivedAt: new Date().toLocaleString() });
    localStorage.setItem("historyTrades", JSON.stringify(history));
  }

  function updateSignalState(sig, latestPrice, coinId){
    if(!sig || sig.status !== "OPEN") return sig;
    const lp = Number(latestPrice);
    if(sig.type === "LONG"){
      if(lp >= Number(sig.takeProfit)) sig.status = "VALIDATED";
      else if(lp <= Number(sig.stopLoss)) sig.status = "INVALIDATED";
    } else if(sig.type === "SHORT"){
      if(lp <= Number(sig.takeProfit)) sig.status = "VALIDATED";
      else if(lp >= Number(sig.stopLoss)) sig.status = "INVALIDATED";
    }
    if(sig.status === "VALIDATED" || sig.status === "INVALIDATED"){
      archiveTrade(coinId, sig);
      delete window.signals[coinId];
      const card = window.cardMap.get(coinId);
      if(card){ card.remove(); window.cardMap.delete(coinId); }
    }
    return sig;
  }

  /* ================== ANALYZE ONE COIN ================== */
  async function analyzeCoin(coin){
    try {
      const ohlc = await fetchDailyOHLC(coin.id);
      if(!ohlc || ohlc.length < 2) return { error: "not enough daily OHLC", coin };
      const lastIdx = ohlc.length - 1;
      const prev = ohlc[lastIdx-1];
      const last = ohlc[lastIdx];
      const closes = ohlc.map(c=>c.c);
      const highs = ohlc.map(c=>c.h);
      const lows = ohlc.map(c=>c.l);
      const ema20 = emaSeriesFromCloses(closes, 20)[lastIdx] || null;
      const ema50 = emaSeriesFromCloses(closes, 50)[lastIdx] || null;
      const ema200 = emaSeriesFromCloses(closes, 200)[lastIdx] || null;
      const atr = ATR(highs, lows, closes, ATR_PERIOD);
      const pa = detectPA(ohlc);
      const piv = pivots_from_prev(prev.h, prev.l, prev.c);
      const dailyOB = findOrderBlocks(ohlc, 60);
      let obZone = null; let obStrength = 0;
      if(dailyOB.bullOB || dailyOB.bearOB){ obZone = dailyOB.bullOB || dailyOB.bearOB; obStrength = 0.5; }
      const baseSignal = generateDailySignal(prev, last, piv, dailyOB);
      const latestPrice = last.c;
      let preferredEntry = latestPrice;
      if(baseSignal && ema20){
        if(baseSignal.type === "LONG") preferredEntry = Math.min(latestPrice, ema20);
        if(baseSignal.type === "SHORT") preferredEntry = Math.max(latestPrice, ema20);
      }
      if(obZone && baseSignal){
        if(baseSignal.type === "LONG") preferredEntry = Math.min(preferredEntry, obZone.low);
        if(baseSignal.type === "SHORT") preferredEntry = Math.max(preferredEntry, obZone.high);
      }
      const obMatch = obZone ? (preferredEntry <= obZone.high && preferredEntry >= obZone.low) : false;
      let pivotMatch = false;
      if(preferredEntry && piv){
        for(const v of [piv.S1, piv.P, piv.R1]){
          if(!v) continue;
          if(Math.abs(preferredEntry - v)/v*100 < 0.8){ pivotMatch = true; break; }
        }
      }
      const paConfirm = (baseSignal && baseSignal.type === "LONG" && pa.engulf === "bull") || (baseSignal && baseSignal.type === "SHORT" && pa.engulf === "bear");
      const alignmentBull = ema20 && ema50 && ema200 && ema20 > ema50 && ema50 > ema200;
      const alignmentBear = ema20 && ema50 && ema200 && ema20 < ema50 && ema50 < ema200;
      const emaAlign = baseSignal ? ((baseSignal.type==="LONG" && alignmentBull) || (baseSignal.type==="SHORT" && alignmentBear)) : false;
      const dist20pct = ema20 ? ((latestPrice - ema20)/ema20)*100 : 0;
      const notOverext = baseSignal ? !(baseSignal.type==="LONG" ? dist20pct > OVEREXT_PCT : baseSignal.type==="SHORT" ? dist20pct < -OVEREXT_PCT : false) : false;
      const confidence = scoreConfidence({emaAlign, paConfirm, obMatch, pivotMatch, notOverext});
      return {
        coin,
        ohlc,
        prev, last,
        baseSignal,
        ema: {ema20, ema50, ema200},
        atr, pa, piv,
        dailyOB, obZone, obStrength,
        preferredEntry,
        obMatch, pivotMatch, paConfirm, emaAlign, notOverext,
        confidence,
        latestPrice
      };
    } catch(e){
      console.error("analyzeCoin err", e);
      return { error: String(e), coin };
    }
  }

  /* ================== RENDER / UPDATES (GG UI) ================== */
  const grid = document.getElementById('grid');
  const statusEl = document.getElementById('status');
  const refreshBtn = document.getElementById('refreshBtn');
  const intervalSel = document.getElementById('interval');
  const displaySel = document.getElementById('displayCount');

  refreshBtn.onclick = ()=> fetchAndRender();
  intervalSel.onchange = ()=> {
    intervalMs = Number(intervalSel.value);
    if(loopHandle) clearInterval(loopHandle);
    loopHandle = setInterval(fetchAndRender, intervalMs);
  };
  displaySel.onchange = ()=> { displayCount = Number(displaySel.value); };

  function strengthColor(val){
    if(val >= 0.7) return "var(--good)";
    if(val >= 0.4) return "#ffd966";
    return "var(--bad)";
  }

  /* Upsert card in place (FILTER OPEN + TRACK) */
  function upsertCard(res, persistedSignal){
    const id = res.coin.id;
    let card = window.cardMap.get(id);
    const c = res.coin;
    const base = res.baseSignal;
    const s = persistedSignal || base || {type:"HOLD", status:"N/A", reason:"-"};
    // Only show active/open signals
    if(!s || String(s.status).toUpperCase() !== "OPEN"){
      // remove existing card if any
      if(card){ card.remove(); window.cardMap.delete(id); }
      return;
    }

    const obStrengthVal = (typeof res.obStrength === 'number' && !isNaN(res.obStrength)) ? res.obStrength : 0;
    const conf = res.confidence || 0;
    const confBadge = `<div class="small badge">Conf ${conf}%</div>`;
    const strBadge = `<div class="small badge" style="color:${strengthColor(obStrengthVal)}">Strength ${(obStrengthVal*100).toFixed(0)}%</div>`;

    const reason = (s.reason || res.baseSignal?.reason || "â").toString().replace(/"/g,'');

    const inner = `
      <div class="h">
        <div>
          <h3>${c.name} (${(c.symbol||"?").toUpperCase()})</h3>
        </div>
        <div>
          ${confBadge}
          ${strBadge}
        </div>
      </div>

      <div class="sig" style="margin-top:10px">
        <div style="font-size:14px;">Signal:
          <strong class="${(s.type==='LONG')?'long':(s.type==='SHORT')?'short':'neutral'}">${s.type}</strong>
          â¢ Status: <span>${s.status}</span>
        </div>
        <div style="margin-top:6px;font-size:14px;">
          <strong>OrigEntry:</strong> ${base?fmtUSD(base.price):'N/A'}
        </div>
        <div style="font-size:14px;">
          <strong>PreferredEntry:</strong> ${fmtUSD(res.preferredEntry)}
        </div>
        <div style="font-size:14px;">
          <strong>TP:</strong> ${s.takeProfit?fmtUSD(s.takeProfit):'N/A'}
          | <strong>SL:</strong> ${s.stopLoss?fmtUSD(s.stopLoss):'N/A'}
        </div>
        <div style="margin-top:6px;font-size:14px;">
          <strong>Reason:</strong> ${reason}
        </div>
        <div style="margin-top:10px;">
          <button class="track-btn" data-coin="${id}">Track</button>
        </div>
      </div>
    `;

    if(card){
      card.innerHTML = inner;
    } else {
      card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = inner;
      grid.appendChild(card);
      window.cardMap.set(id, card);
    }

    // store snapshot for track (avoid string-escaping issues)
    window.cardData[id] = {
      coinId: id,
      name: c.name,
      symbol: (c.symbol||"?").toUpperCase(),
      signalType: s.type,
      analysisStatus: s.status,
      origEntry: base?base.price:null,
      preferredEntry: res.preferredEntry || null,
      tp: s.takeProfit || null,
      sl: s.stopLoss || null,
      reason: reason,
      timestamp: Date.now()
    };

    // attach click handler for track button (safe)
    const btn = card.querySelector('.track-btn');
    if(btn){
      btn.onclick = ()=> trackTrade(id);
    }
  }

  function renderErrors(errors){
    const existing = document.getElementById('errors-card');
    if(existing) existing.remove();
    if(!errors || !errors.length) return;
    const ec = document.createElement('div');
    ec.className = 'card';
    ec.id = 'errors-card';
    const list = errors.map(e=>{
      const name = e.coin ? `${e.coin.name} (${(e.coin.symbol||"?").toUpperCase()})` : 'Unknown';
      return `<div style="margin-bottom:6px"><strong>${name}</strong> â <span class="small muted">${String(e.error)}</span></div>`;
    }).join('');
    ec.innerHTML = `<details><summary>â ï¸ Errors (${errors.length}) â click to expand</summary><div style="margin-top:8px">${list}</div></details>`;
    grid.appendChild(ec);
  }

  /* ================== ORCHESTRATION: continuous scan ================== */
  async function fetchAndRender(){
    try {
      statusEl.innerHTML = `Fetching top ${TOP_SCAN} <span class="spinner"></span>`;
      const top = await fetchTopCoins(TOP_SCAN);
      const errors = [];
      let rendered = 0;
      for(let i=0; i<top.length && rendered < displayCount; i++){
        const coin = top[i];
        statusEl.innerHTML = `Analyzing ${i+1}/${top.length}: ${coin.name} <span class="spinner"></span>`;
        const res = await analyzeCoin(coin);
        if(res && res.error){
          errors.push(res);
          continue;
        }
        if(!res) continue;

        // persist baseSignal only if there isn't an open signal already
        const existing = window.signals[res.coin.id];
        if(res.baseSignal && (!existing || existing.status !== "OPEN")){
          window.signals[res.coin.id] = {
            type: res.baseSignal.type,
            status: res.baseSignal.status,
            date: res.baseSignal.date,
            price: res.baseSignal.price,
            stopLoss: res.baseSignal.stopLoss,
            takeProfit: res.baseSignal.takeProfit,
            reason: res.baseSignal.reason
          };
        }

        // update existing open signal with live price and close it if needed
        const livePrice = await fetchCurrentPrice(res.coin.id);
        if(livePrice != null && window.signals[res.coin.id]){
          const updated = Object.assign({}, window.signals[res.coin.id]);
          updateSignalState(updated, livePrice, res.coin.id);
          window.signals[res.coin.id] = updated;
        }

        const signalState = window.signals[res.coin.id] || res.baseSignal || null;

        // ONLY render open signals (upsertCard will also skip non-open)
        if(signalState && String(signalState.status).toUpperCase() === "OPEN"){
          upsertCard(res, signalState);
          rendered++;
        } else {
          // ensure card removed if exists
          const card = window.cardMap.get(res.coin.id);
          if(card){ card.remove(); window.cardMap.delete(res.coin.id); }
        }

        await sleep(150);
      }

      renderErrors(errors);
      statusEl.textContent = `Last update: ${new Date().toLocaleTimeString()}`;
    } catch(e){
      console.error("fetchAndRender err", e);
      statusEl.textContent = "Error fetching data";
    }
  }

  // Start scanning immediately, then repeat at interval
  fetchAndRender();
  loopHandle = setInterval(fetchAndRender, intervalMs);

  /* ================== TRACK -> save snapshot to user's watchlist ================== */
  async function trackTrade(coinId){
    const user = auth.currentUser;
    if(!user){
      alert("Please log in to track trades");
      return;
    }
    const snapshot = window.cardData[coinId];
    if(!snapshot){
      alert("No data available to track (try again)");
      return;
    }
    try {
      await addDoc(collection(db, "users", user.uid, "watchlist"), {
        coinId: snapshot.coinId,
        name: snapshot.name,
        symbol: snapshot.symbol,
        signalType: snapshot.signalType,
        analysisStatus: snapshot.analysisStatus,
        origEntry: snapshot.origEntry,
        preferredEntry: snapshot.preferredEntry,
        tp: snapshot.tp,
        sl: snapshot.sl,
        reason: snapshot.reason,
        trackedAt: Date.now()
      });
      alert("Added to your Watchlist");
    } catch(e){
      console.error("trackTrade error", e);
      alert("Failed to add to watchlist");
    }
  }

</script>
</body>
</html>